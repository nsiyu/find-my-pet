type PinataConfig = {
    pinataJwt?: string;
    pinataGateway?: string;
    pinataGatewayKey?: string;
    customHeaders?: Record<string, string>;
    endpointUrl?: string;
    uploadUrl?: string;
};
type AuthTestResponse = {
    message: string;
};
type UploadResponse = {
    id: string;
    name: string;
    cid: string;
    size: number;
    created_at: string;
    number_of_files: number;
    mime_type: string;
    user_id: string;
    group_id: string | null;
};
type FileObject = {
    name: string;
    size: number;
    type: string;
    lastModified: number;
    arrayBuffer: () => Promise<ArrayBuffer>;
};
type JsonBody = Record<string, unknown>;
type PinataMetadata = {
    name?: string;
};
type UpdateFileOptions = {
    id: string;
    name?: string;
    keyvalues?: Record<string, string>;
};
type UploadOptions = {
    metadata?: PinataMetadata;
    keys?: string;
    groupId?: string;
};
type DeleteResponse = {
    id: string;
    status: string;
};
type FileListItem = {
    id: string;
    name: string | null;
    cid: "pending" | string;
    size: number;
    number_of_files: number;
    mime_type: string;
    keyvalues: Record<string, string>;
    group_id: string | null;
    created_at: string;
};
type FileListResponse = {
    files: FileListItem[];
    next_page_token: string;
};
type FileListQuery = {
    name?: string;
    group?: string;
    mimeType?: string;
    cid?: string;
    cidPending?: boolean;
    metadata?: Record<string, string>;
    order?: "ASC" | "DESC";
    limit?: number;
    pageToken?: string;
};
type PinJobQuery = {
    sort?: "ASC" | "DSC";
    status?: "prechecking" | "retrieving" | "expired" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node";
    ipfs_pin_hash?: string;
    limit?: number;
    offset?: number;
};
type PinJobItem = {
    id: string;
    ipfs_pin_hash: string;
    date_queued: string;
    name: string;
    status: string;
    keyvalues: any;
    host_nodes: string[];
    pin_policy: {
        regions: {
            id: string;
            desiredReplicationCount: number;
        }[];
        version: number;
    };
};
type PinJobResponse = {
    rows: PinJobItem[];
};
type ContentType = "application/json" | "application/xml" | "text/plain" | "text/html" | "text/css" | "text/javascript" | "application/javascript" | "image/jpeg" | "image/png" | "image/gif" | "image/svg+xml" | "audio/mpeg" | "audio/ogg" | "video/mp4" | "application/pdf" | "application/octet-stream" | string | null;
type GetCIDResponse = {
    data?: JSON | string | Blob | null;
    contentType: ContentType;
};
type OptimizeImageOptions = {
    width?: number;
    height?: number;
    dpr?: number;
    fit?: "scaleDown" | "contain" | "cover" | "crop" | "pad";
    gravity?: "auto" | "side" | string;
    quality?: number;
    format?: "auto" | "webp";
    animation?: boolean;
    sharpen?: number;
    onError?: boolean;
    metadata?: "keep" | "copyright" | "none";
};
type SignedUrlOptions = {
    cid: string;
    date?: number;
    expires: number;
    gateway?: string;
};
type GatewayAnalyticsQuery = {
    gateway_domain: string;
    start_date: string;
    end_date: string;
    cid?: string;
    file_name?: string;
    user_agent?: string;
    country?: string;
    region?: string;
    referer?: string;
    limit?: number;
    sort_order?: "asc" | "desc";
};
type TopGatewayAnalyticsQuery = GatewayAnalyticsQuery & {
    sort_by: "requests" | "bandwidth";
    attribute: "cid" | "country" | "region" | "user_agent" | "referer" | "file_name";
};
type TopGatewayAnalyticsItem = {
    value: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalGatewayAnalyticsQuery = GatewayAnalyticsQuery & {
    sort_by?: "requests" | "bandwidth";
    date_interval: "day" | "week";
};
type TimePeriodItem = {
    period_start_time: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalGatewayAnalyticsResponse = {
    total_requests: number;
    total_bandwidth: number;
    time_periods: TimePeriodItem[];
};
type UserPinnedDataResponse = {
    pin_count: number;
    pin_size_total: number;
    pin_size_with_replications_total: number;
};
type KeyPermissions = {
    admin?: boolean;
    endpoints?: Endpoints;
};
type Endpoints = {
    data?: DataEndponts;
    pinning?: PinningEndpoints;
};
type DataEndponts = {
    pinList?: boolean;
    userPinnedDataTotal?: boolean;
};
type PinningEndpoints = {
    hashMetadata?: boolean;
    hashPinPolicy?: boolean;
    pinByHash?: boolean;
    pinFileToIPFS?: boolean;
    pinJSONToIPFS?: boolean;
    pinJobs?: boolean;
    unpin?: boolean;
    userPinPolicy?: boolean;
};
type KeyOptions = {
    keyName: string;
    permissions: KeyPermissions;
    maxUses?: number;
};
type KeyResponse = {
    JWT: string;
    pinata_api_key: string;
    pinata_api_secret: string;
};
type KeyListQuery = {
    revoked?: boolean;
    limitedUse?: boolean;
    exhausted?: boolean;
    name?: string;
    offset?: number;
};
type KeyListItem = {
    id: string;
    name: string;
    key: string;
    secret: string;
    max_uses: number;
    uses: number;
    user_id: string;
    scopes: KeyScopes;
    revoked: boolean;
    createdAt: string;
    updatedAt: string;
};
type KeyScopes = {
    endpoints: {
        pinning: {
            pinFileToIPFS: boolean;
            pinJSONToIPFS: boolean;
        };
    };
    admin: boolean;
};
type KeyListResponse = {
    keys: KeyListItem[];
    count: number;
};
type RevokeKeyResponse = {
    key: string;
    status: string;
};
type GroupOptions = {
    name: string;
    isPublic?: boolean;
};
type UpdateGroupOptions = {
    groupId: string;
    name?: string;
    isPublic?: boolean;
};
type GetGroupOptions = {
    groupId: string;
};
type GroupListResponse = {
    groups: GroupResponseItem[];
    next_page_token: string;
};
type GroupResponseItem = {
    id: string;
    is_public: boolean;
    name: string;
    createdAt: string;
};
type GroupQueryOptions = {
    name?: string;
    limit?: number;
    pageToken?: string;
    isPublic?: boolean;
};
type GroupCIDOptions = {
    groupId: string;
    cids: string[];
};
type SignatureOptions = {
    cid: string;
    signature: string;
};
type SignatureResponse = {
    cid: string;
    signature: string;
};
type SwapCidOptions = {
    cid: string;
    swapCid: string;
};
type SwapHistoryOptions = {
    cid: string;
    domain: string;
};
type SwapCidResponse = {
    mapped_cid: string;
    created_at: string;
};
type ContainsCIDResponse = {
    containsCid: boolean;
    cid: string | null;
};

declare class PinataSDK {
    config: PinataConfig | undefined;
    files: Files;
    upload: Upload;
    gateways: Gateways;
    keys: Keys;
    groups: Groups;
    constructor(config?: PinataConfig);
    setNewHeaders(headers: Record<string, string>): void;
    setNewJwt(jwt: string): void;
    testAuthentication(): Promise<AuthTestResponse>;
}
declare class Files {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    list(): FilterFiles;
    delete(files: string[]): Promise<DeleteResponse[]>;
    update(options: UpdateFileOptions): Promise<FileListItem>;
    addSwap(options: SwapCidOptions): Promise<SwapCidResponse>;
    getSwapHistory(options: SwapHistoryOptions): Promise<SwapCidResponse[]>;
    deleteSwap(cid: string): Promise<string>;
}
declare class UploadBuilder<T> {
    private config;
    private uploadFunction;
    private args;
    private metadata;
    private keys;
    private groupId;
    constructor(config: PinataConfig | undefined, uploadFunction: (config: PinataConfig | undefined, ...args: any[]) => Promise<T>, ...args: any[]);
    addMetadata(metadata: PinataMetadata): UploadBuilder<T>;
    key(jwt: string): UploadBuilder<T>;
    group(groupId: string): UploadBuilder<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
}
declare class Upload {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    file(file: FileObject, options?: UploadOptions): UploadBuilder<UploadResponse>;
    base64(base64String: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    url(url: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    json(data: object, options?: UploadOptions): UploadBuilder<UploadResponse>;
}
declare class FilterFiles {
    private config;
    private query;
    private currentPageToken;
    constructor(config: PinataConfig | undefined);
    name(name: string): FilterFiles;
    group(group: string): FilterFiles;
    cid(cid: string): FilterFiles;
    mimeType(mimeType: string): FilterFiles;
    order(order: "ASC" | "DESC"): FilterFiles;
    limit(limit: number): FilterFiles;
    cidPending(cidPending: boolean): FilterFiles;
    metadata(keyvalues: Record<string, string>): FilterFiles;
    pageToken(pageToken: string): FilterFiles;
    then(onfulfilled?: ((value: FileListResponse) => any) | null): Promise<any>;
    private fetchPage;
    [Symbol.asyncIterator](): AsyncGenerator<FileListItem, void, unknown>;
    all(): Promise<FileListItem[]>;
}
declare class Gateways {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    get(cid: string): OptimizeImageGetCid;
    createSignedURL(options: SignedUrlOptions): OptimizeImageCreateSignedURL;
}
declare class OptimizeImageGetCid {
    private config;
    private cid;
    private options;
    constructor(config: PinataConfig | undefined, cid: string);
    optimizeImage(options: OptimizeImageOptions): OptimizeImageGetCid;
    then(onfulfilled?: ((value: GetCIDResponse) => any) | null): Promise<any>;
}
declare class OptimizeImageCreateSignedURL {
    private config;
    private urlOpts;
    private imgOpts;
    constructor(config: PinataConfig | undefined, urlOpts: SignedUrlOptions);
    optimizeImage(options: OptimizeImageOptions): OptimizeImageCreateSignedURL;
    then(onfulfilled?: ((value: string) => any) | null): Promise<any>;
}
declare class Keys {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: KeyOptions): Promise<KeyResponse>;
    list(): FilterKeys;
    revoke(keys: string[]): Promise<RevokeKeyResponse[]>;
}
declare class FilterKeys {
    private config;
    private query;
    constructor(config: PinataConfig | undefined);
    offset(offset: number): FilterKeys;
    revoked(revoked: boolean): FilterKeys;
    limitedUse(limitedUse: boolean): FilterKeys;
    exhausted(exhausted: boolean): FilterKeys;
    name(name: string): FilterKeys;
    then(onfulfilled?: ((value: KeyListItem[]) => any) | null): Promise<any>;
    [Symbol.asyncIterator](): AsyncGenerator<KeyListItem, void, unknown>;
    all(): Promise<KeyListItem[]>;
}
declare class Groups {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: GroupOptions): Promise<GroupResponseItem>;
    list(): FilterGroups;
    get(options: GetGroupOptions): Promise<GroupResponseItem>;
    update(options: UpdateGroupOptions): Promise<GroupResponseItem>;
    delete(options: GetGroupOptions): Promise<string>;
}
declare class FilterGroups {
    private config;
    private query;
    private nextPageToken;
    constructor(config: PinataConfig | undefined);
    name(name: string): FilterGroups;
    limit(limit: number): FilterGroups;
    isPublic(isPublic: boolean): FilterGroups;
    pageToken(pageToken: string): FilterGroups;
    then(onfulfilled?: ((value: GroupListResponse) => any) | null): Promise<GroupListResponse>;
    private fetchPage;
    [Symbol.asyncIterator](): AsyncGenerator<GroupResponseItem, void, unknown>;
    all(): Promise<GroupResponseItem[]>;
}

export { type AuthTestResponse, type ContainsCIDResponse, type ContentType, type DataEndponts, type DeleteResponse, type Endpoints, type FileListItem, type FileListQuery, type FileListResponse, type FileObject, type GatewayAnalyticsQuery, type GetCIDResponse, type GetGroupOptions, type GroupCIDOptions, type GroupListResponse, type GroupOptions, type GroupQueryOptions, type GroupResponseItem, type JsonBody, type KeyListItem, type KeyListQuery, type KeyListResponse, type KeyOptions, type KeyPermissions, type KeyResponse, type OptimizeImageOptions, type PinJobItem, type PinJobQuery, type PinJobResponse, type PinataConfig, type PinataMetadata, PinataSDK, type PinningEndpoints, type RevokeKeyResponse, type SignatureOptions, type SignatureResponse, type SignedUrlOptions, type SwapCidOptions, type SwapCidResponse, type SwapHistoryOptions, type TimeIntervalGatewayAnalyticsQuery, type TimeIntervalGatewayAnalyticsResponse, type TimePeriodItem, type TopGatewayAnalyticsItem, type TopGatewayAnalyticsQuery, type UpdateFileOptions, type UpdateGroupOptions, type UploadOptions, type UploadResponse, type UserPinnedDataResponse };
